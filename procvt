#!perl

=head1 NAME

procvt - Convert an old prologue to modern STARLSE style

=head1 SYNOPSIS

  procvt *.f
  cat test.f | procvt > new.f

=head1 OPTIONS

If source code is piped directly into the command, the prologue
is parsed and the modified source code is sent to standard out.

If files are supplied as arguments, each file is processed in turn
and if the prologue is not in STARLSE form the file will be modified
to use a modern prologue.

=over 4

=item B<-version>

Report the version number.

=item B<-help>

Display the help information.

=item B<-man>

Display the full manual page.

=back

=cut

use strict;
use warnings;
use Pod::Usage;
use Getopt::Long;

use Starlink::Prologue;
use Starlink::Prologue::Parser;

# Options
my ($help, $man, $version);
my $status = GetOptions("help" => \$help,
                        "man" => \$man,
                        "version" => \$version,
                       );

pod2usage(1) if $help;
pod2usage(-exitstatus => 0, -verbose => 2) if $man;

if ($version) {
  my $id = '$Id$ ';
  print "procvt - modernise a Starlink prologue\n";
  print " CVS revision: $id\n";
  exit;
}

# do we have standard input or file arguments?

if (@ARGV) {
  # files on command line
  for my $file (@ARGV) {
    open(my $fh, "<$file") || die "Error opening file $file for read: $!\n";
    my ($types, $rewrite) = _convert_header( join("", <$fh>), $file );
    close($fh) || die "Error closing input file $file: $!\n";

    if (@$types) {
      my $converted;
      for my $t (@$types) {
	if ($t ne 'STARLSE') {
	  $converted = 1;
	  last;
	}
      }
      if ($converted) {
	my %types = map { $_, undef } @$types;
	print STDERR "Prologue in file $file contains ", join(", ",keys %types),
	  " prologues. Converting...\n";

	# open the input file for write
	open( my $fh, ">", $file) || 
	  die "Error opening file $file for writing modified prologue: $!";
	print $fh $rewrite;
	close( $fh ) || die "Error closing output file $file: $!\n";

      } else {
	print STDERR "Prologue in file $file does not need to be converted\n";
      }
    } else {
      print STDERR "No prologue located in file $file\n";
    }
  }
} else {
  # try reading from pipe
  my @lines = <>;
  if (@lines) {
    my ($types, $rewrite) = _convert_header( join("", @lines) );
    my %types = map { $_, undef } @$types;
    print STDERR "Supplied prologue contains ", join(", ", keys %types), " prologues. Converting...\n";
    print $rewrite;
  } else {
    print STDERR "Please supply files to modify or source code via stdin\n";
  }
}

exit;

# Given a string containing the source code, rewrite the header
# and return the result as a string. Second argument is the filename
# that can be used to determine Language (can be undef).
# Returns:
#  - reference to array of strings indicating which types the
#    prologues were (allowing the caller to skip if the prologue
#    has not been converted)
#  - modified source code as a single string

sub _convert_header {
  my $input = shift;
  my $file = shift;

  # Create a parser and parse all the source code
  my $parser = new Starlink::Prologue::Parser;
  my @parsed = $parser->parse_lines( split /\n/, $input );

  # process the lines and update unknown fields

  my @types; # all processed types
  my $type; # Type of most recent prologue
  my $rewrite = ''; # rewritten source

  for my $entry (@parsed) {

    # if we have a prologue it needs to be stringified
    if (ref $entry) {

      # fix up language if not defined
      if (!@{$entry->language}) {
	if (!defined $file) {
	  # assume that old prologue is always Fortran!
	  my @type = @{$entry->type_of_module};
	  if (@type && $entry->prologue_type eq 'ADAMSSE' &&
	      $type[0] =~ /(SUBROUTINE|BLOCK DATA|PROGRAM)/) {
	    $entry->language("Starlink Fortran 77");
	  }
	} elsif ($file =~ /\./) {
	  # File has a suffix
	  my @parts = split /\./,$file;
	  
	  my $lang;
	  my $suffix = $parts[-1];
	  if ($suffix =~ /^(for|f)$/i) {
	    $lang = "Starlink Fortran 77" ;
	  } elsif ($suffix =~ /^(pl|pm)$/) {
	    $lang = "Perl";
	  } elsif ($suffix eq 'c') {
	    $lang = "Starlink C";
	  } elsif ($suffix eq 'C' || $suffix eq 'cc') {
	    $lang = "Starlink C++";
	  } elsif ($suffix eq 'sh' ) {
	    $lang = "Bourne shell";
	  } elsif ($suffix eq 'csh' ) {
	    $lang = "C-shell";
	  }
	  $entry->language( $lang ) if defined $lang;

	} else {
	  # now things are getting hard so assume Starlink conventions
	  if ($file =~ /_(ERR|SYS|CMN|PAR)$/i ) {
	    $entry->language( "Starlink Fortran 77" );
	  }
	}
      }

      # fix up type of module
      my @type_of_module = @{$entry->type_of_module};
      if (!@type_of_module) {
	if (defined $file) {
	  if ($file =~ /_CMN$/i) {
	    $entry->type_of_module( "COMMON BLOCK" );
	  } elsif ($file =~ /_(ERR|PAR|SYS)$/i ) {
	    $entry->type_of_module( "FORTRAN INCLUDE" );
	  }
	}
      }
      # stringify the prologue
      $rewrite .= $entry->stringify;
      $type = $entry->prologue_type;
      push(@types, $type);

    } else {
      # if we just have a line we need to print it out
      $rewrite .= _rewrite_line( $type, $entry ) ."\n";
    }

  }

  return (\@types, $rewrite);
}

# in ADAMSSE prologues we should tweak some of the variable
# sections

sub _rewrite_line {
  my ($type, $line) = @_;
  return $line unless (defined $type && $type eq 'ADAMSSE');

  if ($line =~ /^\s*\*\-\s*$/) {
    return "*.";
  } elsif ($line =~ /^\s*\*\s+Type Definitions\s*:$/i) {
    return "*  Type Definitions:";
  } elsif ($line =~ /^\s*\*\s+Global Constants\s*:$/i) {
    return "*  Global Constants:";
  } elsif ($line =~ /^\s*\*\s+Local Constants\s*:$/i) {
    return "*  Local Constants:";
  } elsif ($line =~ /^\s*\*\s+Local Variables\s*:$/i) {
    return "*  Local Variables:";
  } elsif ($line =~ /^\s*\*\s+Global Variables\s*:$/i) {
    return "*  Global Variables:";
  } elsif ($line =~ /^\s*\*\s+Status\s*:$/i) {
    return "*  Status:";
  } elsif ($line =~ /^\s*\*\s+Import\s*:$/i) {
    return "*  Arguments Given:";
  } elsif ($line =~ /^\s*\*\s+Export\s*:$/i) {
    return "*  Arguments Returned:";
  } elsif ($line =~ /^\s*\*\s+Import-Export\s*:$/i) {
    return "*  Arguments Given and Returned:";
  }
  return $line;
}


=head1 SEE ALSO

SST application.

=head1 AUTHOR

Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt>

Copyright 2006 Particle Physics and Astronomy Research Council.
All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful,but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place,Suite 330, Boston, MA  02111-1307, USA

=cut

1;
